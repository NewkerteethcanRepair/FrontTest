# **Html**

#### h5常用结构标签：**

1. <header></header>

2. <nav></nav>

3. <section></section>

4. <aside></aside>

5. <footer></footer>✨眼神要好

6. <article></article>

#### H5版本中新提出的表单控件

1. 电子邮件

   <input type="email">

   表单提交时，会验证数据是否符号email的规范（有@，并且@后面有内容）

2. 搜索类型

   <input type="search">

   提供了快速清除的功能

3. url类型

   <input type="url">

   提交时，验证数据是否符合url的规范（http://****）

4. 电话号码类型

   <input type="tel">

   在移动设备中，显示拨号键盘

5. 数字类型

   <input type="number">

   属性：

   - value 默认显示的值
   - max 能接收到的最大值
   - min 能接收到的最小值
   - step 每次调整数字时，步数大小

6. 范围类型

   <input type="range">

   提供一个滑块组件，允许用户选取指定范围的值

   属性：

   - value 默认显示的值
   - max 最大值
   - min 最小值
   - step 步长

7. 颜色类型

   <input type="color">

   提供一个颜色拾取器✨

8. 日期类型

   <input type="date">

9. 月份类型

   <input type="month">

10. 周类型

    <input type="week">

#### **文字换行**

**不换行也不省略 ：** 

word-break : keep-all;

white-space : nowrap; 

**不换行，超出用省略号代替 :** 

word-break : keep-all;

white-space : nowrap;

overflow : hidden;

text-overflow : ellipsis;



#### 动画

transform:旋转 div 元素;

translate:移动，是transform的一个方法;

transition:属性是一个简写属性，用于设置四个过渡属性：

# **css**

D是对的，解析CSS构建CSSOM会阻塞JS的执行，不阻塞JS的加载。所以要把CSS文件放在前面加载。

#### 什么是重绘与回流？

重绘就是重新绘制，比如display：none 就是回流 和 visibility：hidden 就是重绘



**答案**

浏览器在加载页面的时候会生成一个render（渲染）树，加载完成后当渲染树中的某一些元素发生了比如形状，尺寸，隐藏，由于元素之间位置的相互关系发生改变，都会使渲染树发生改变，从而需要重新构建渲染树，这叫回流
而当渲染树中的某些元素发生的改变不会影响个元素之间的位置关系，比如color，background等只是改变外观，则不需要重建渲染树，这就叫做重绘。
区别:当发生回流时一定发生了重绘，但是当发生重绘时则不一定发生回流





#### 响应式和自适应的区别是什么？

响应式布局，只要页面宽度大小或者高度大小发生变化时，页面的布局会随着页面页面宽度改变而改变布局 最常用的是media，也可以是用一些ui的布局实现响应式，

自适应布局，根据 页面的宽度或者高度，自己识别响应的布局。 



答案：

响应式网页布局设计就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。打个比方来说：现在社会有很多响应产品，例如折叠沙发，折叠床等等，当我们需要把沙发放到一个角落的时候，此刻沙发就好比div吧，而角落里的某个地方就好比父元素，由于父元素空间的改变，我们不得不调整div,让它能够依然放在角落里。在项目中你会遇到不同的终端，由于终端分辨率不同，所以你要想让用户体验更好，就必要让你的页面能够兼容多个终端。

 自适应网页布局设计指网页能够在不同大小的终端设备上自行适应显示。简单来说：就是让一个网站在不同大小的设备上呈现显示同一样的页面，让同一个页面适应不同大小屏幕，根据屏幕的大小，自动缩放。

# **JS**

```
[...[``1``,,``3``,,``5``]].map((_, n) => n);
```

map遍历回调函数传两个参数，第一个是item，第二个是index,这里返回的是index,即数组下标，所有是[0,1,2,3,4]

#### **JavaScript 中包含哪些数据类型？**

基本类型 string number Boolean  underfind null symbol

引用类型  array object

#### **箭头函数与普通函数的区别是什么？**

this的指向不同，箭头函数不会影响this，this指代他的上级

**答案：**

**一.外形不同：**

箭头函数使用箭头定义，普通函数中没有。

```
// 普通函数
function` `func(){
 ``// code
}
// 箭头函数
let` `func=()=>{
 ``// code
}
```

**二.箭头函数全都是匿名函数：**

普通函数可以有匿名函数，也可以有具名函数。

```
// 箭头函数全都是匿名函数
let` `func=()=>{
 ``// code
}
```

**三.箭头函数不能用于构造函数：**

普通函数可以用于构造函数，以此创建对象实例。

```
function` `Antzone(webName,age){
  ``this``.webName=webName;
  ``this``.age=age;
}
let` `antzone=``new` `Antzone(``"蚂蚁部落"``,5);
console.log(antzone.webName);
```

**四.箭头函数中this的指向不同：**

this一直是让初学者比较头疼的概念。

在普通函数中，this总是指向调用它的对象或者，如果用作构造函数，它指向创建的对象实例。

（1）默认指向定义它时，所处上下文的对象的this指向。即ES6箭头函数里this的指向就是上下文里对象this指向，偶尔没有上下文对象，this就指向window

（2）即使是call，apply，bind等方法也不能改变箭头函数this的指向




**五.箭头函数不具有arguments对象：**

每一个普通函数调用后都具有一个arguments对象，用来存储实际传递的参数。

但是箭头函数并没有此对象。

关于arguments对象可以参阅[JavaScript arguments对象](https://www.softwhy.com/article-8818-1.html)一章节。

**六.其他区别：**

（1）.箭头函数不能Generator函数。

（2）.箭头函数不具有prototype原型对象。

（3）.箭头函数不具有super。

（4）.箭头函数不具有new.target。



#### 列举几种你知道的实现数组去重的方式。

1 new set 可以去除，

```
let arr=[xxxx,xx]
let s=new.set(arr)
```

2.通过indexOf
注：如果要检索的字符串值没有出现，只会查找某数据第一次出现的位置，则该方法返回 -1

```
for(var i=0; i<len;i++){
    var arr=array[i];
    if(array1.indexOf(arr)===-1){ 
        array1.push(arr);
     }
```



3  双循环 遍历







#### 什么是垃圾回收机制？

不要的就丢了



***答案**：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。*



```
var a = "before";
var b = "override a";
var a = b; //重写a
```

　　这段代码运行之后，“before”这个字符串失去了引用（之前是被a引用），系统检测到这个事实之后，就会释放该字符串的存储空间以便这些空间可以被再利用。

#### 什么是闭包

简单来说 就是函数a里面定义了一个函数b，函数b可以使用函数a的所有变量和参数，我们就将这种情况称为闭包

优点： 闭包可以缓存数据，延长作用域链，在函数内部使用父级作用域的变量，可以缓存数据

缺点：用了后，局部变量不能及时释放。

#### 为什么要用setTimeout模拟setInterval ？

setInterval缺点 与 setTimeout

> 再次强调，定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取到，并执行。

综上所述，setInterval有两个缺点：

**使用setInterval时，某些间隔会被跳过；
可能多个定时器会连续执行；
可以这么理解：每个setTimeout产生的任务会直接push到任务队列中；而setInterval在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)。

因而我们一般用setTimeout模拟setInterval，来规避掉上面的缺点。

#### 递归

就是调用自己的一种编程技巧，在程序中广泛使用。比如 用settimeout代替 setinterval， 是循环运算的一种模式

满足要求：

1.递归调用必须要有结束条件。

2.递归要有调用过程



#### **循环中保存循环变量 只能保存到最后一次循环变量的值**（let）

解决：使用let ，

let变量  和 const 变量

let 是 es6 语法 中关键的子， 定义局部变量， 让js 有了真正的块级作用域。 没有变量提升

**作用**：新增块级作用域，弥补了vaar 关键字的一些缺陷。

**使用**：使用let 可以定义局部变量，let 定义的变量只能在当前的代码块运行

**特点**： 

块级作用域  

不存在变量的提升  

暂时性死区



#### **浅克隆 深克隆**





#### **继承 多态**

# **VUE**

#### 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

如果不写key的话，会报错, 因为列表组件 不唯一

**答案**：vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中（建议先了解一下diff算法过程）。
在交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点（这里对应的是一个key => index 的map？映射）。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言，map映射的**速度更快**。

**因为更快更精确**

#### **Vue 的组件中 data** 为什么不能是对象？

不是都是对象吗？

**答案**：`data`数据都应该是相互隔离，互不影响的

因为如果是对象的话，那么其他组件改变data里面的某属性值，其他的组件在使用data的这个属性值时，属性值也改变了，所以用 利用函数 return，每次返回的都是一个新的data 

React 中 setState 什么时候是同步的，什么时候是异步的？

当不再事件中都是同步的

**答案**  setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。

合成事件：就是react 在组件中的onClick等都是属于它自定义的合成事件

原生事件：比如通过addeventListener添加的，dom中的原生事件


#### 



#### Vue 中 watch 和 computed 的区别是什么？

Vue中watch常用于监听 data数据改变，而computer用于 处理data的逻辑运算。

答案：computed 可以关联多个实时计算的对象，支持缓存，只有依赖数据发送改变，才会重新进行计算。

不支持异步，当computed内有异步操作时无效，无法监听数据的变化

computed 属性值会默认走缓存，计算属性是基于他们的响应式依赖进行缓存的，





#### ***简单描述 Vue 2.x 中响应式的原理。

　　Vue 的响应式原理是核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM 树上。

# **REACT**

#### **React 中函数组件和类组件有什么区别？**

函数组件 没有生命周期也没有state，如果要使用类似state 要借用hook

而类组件都有，所以可以实现更多的功能，比如 props传值问题

答案：函数组件和类组件，首先，函数组件性能要比类组件性能高，

因为类组件使用需要 实例化，而函数组件直接执行返回结果就ok，

函数组件没有 this，没有生命周期，没有状态state，如果要实现更多功能可以用hook

而类组件 有this, 有生命周期，有state





#### **什么是 MVVM？与 MVC 有什么区别？**

M: Model 数据模型，专门用来操作数据，数据的CRUD。

V：View 视图，就是我们在浏览器中所看到的页面。

C：Controller 控制器，是视图和数据模型沟通的桥梁，处理业务逻辑都在控制器。

M：model数据模型，专门用来操作数据，数据的CRUD。

V：view视图，就是我们在浏览器中所看到的页面。

VM：ViewModel 视图模型，这个是数据的核心。

MVVM model（ 数据模型）-view-viewmodel。 mvc model -view- Controller（ 管理者，控制者,即这里用于业务逻辑）

即mvc 的 view 可以直接访问 model 

**MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View。**

![image-20200406194051121](C:\Users\newteethqaq\AppData\Roaming\Typora\typora-user-images\image-20200406194051121.png)

**MVVM通过`数据双向绑定`让数据自动地双向同步，V修改数据自动同步M、M修改数据自动同步到V** 

**Vue就是这种MVVM模式的框架，无需开发人员手动操作DOM，开发人员只需要关注数据。**

![image-20200406194448400](C:\Users\newteethqaq\AppData\Roaming\Typora\typora-user-images\image-20200406194448400.png)

#### **什么是 Virtual DOM？**

虚拟dom 虚拟节点 它通过 `JS` 的 `Object` 对象模拟 `DOM` 中的节点，然后再通过特定的 `render` 方法将其渲染成真实的 `DOM` 节点。 

1. dom操作是非常昂贵的，而虚拟dom操作 通过对比在判断操作，提高效率
2. js的运行效率是非常高的

#### **在 React 中如何实现实现父子组件、兄弟组件之间的传值？**

父子 自定义属性 传数据 子组件 props 接收即可， 

子组件（通过this.props.事件名(参数)的方式向父组件传递参数）



**兄弟组件之间的传值**

  **两个兄弟组件之间会有一个共同的父组件，我们都是结合父子传值的方式来实现兄弟之间的传值的，即先其中一个子组件（兄弟组件）向父组件传值，然后父组件接收到这个值之后再将值传递给另外一个子组件（兄弟组件）**



#### 在 React 的事件中，多次调用 setState 方法，render 会执行多少次？

一般来说 只要默认情况使用Component 那么使用多少次setState render就会执行多少次， 但是如果使用Purecomponent

# 其他知识

## WebPack

## 数据库

#### **cookie、localStorage 和 sessionStorage 有什么区别？**

cookie 和localStorage 都是 自身浏览器的 东西， 他是浏览器处理本地化存储的一种方式，而sessionStorage 是服务器上 后端存储数据的一种方式. 而且cookie是以前的技术，且有数据大小限制 比较小，而localStorage 都是10mb的上限。

答案： 共同点，都是保存在浏览器端。

区别： cookie要在**浏览器和服务器来回传递**，而localStorage 和sessionStorage  **不会发送给服务器，只在本地保存**

2 cookie 存储数据大小不能超过4k，而其他两者要大的多，有5m

3 数据有效期不同，sessionStorage 在浏览器窗口关闭之前有效，localStorage

始终有效，除非你删掉，cookie要在 过期找时间之前有效。

4 三者的异同

| 特性           | Cookie                                                       | localStorage                                                | sessionStorage                               |
| :------------- | :----------------------------------------------------------- | :---------------------------------------------------------- | :------------------------------------------- |
| 数据的生命期   | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存                                    | 仅在当前会话下有效，关闭页面或浏览器后被清除 |
| 存放数据大小   | 4K左右                                                       | 一般为5MB                                                   |                                              |
| 与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信          |                                              |
| 易用性         | 需要程序员自己封装，源生的Cookie接口不友好                   | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 |                                              |



**session 是服务端的，cookie 是前端的。**
**我们数据保存在服务端的 session 里，保存成功后，会有一个 session 的标记返回到前端，然后保存在 cookie 里**
**你可以理解成 sessionid**
**session 保存成功后，会返回一个 sessionid 给前端，前端把这个 sessionid 保存在 cookie 里**







 

**更简单来说** 

1.首先从字面意思来看,computed是一个计算的属性,类似过滤器,对数据进行处理后return一个新的state,并且可以监听该返回值的变化,而watch是观察是一个动作;

computed

1.是计算值，
2.应用：就是简化tempalte里面{{}}计算和处理props或$emit的传值
3.具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数

watch特性

1.是观察的动作，
2.应用：监听props，$emit或本组件的值执行异步操作
3.无缓存性，页面重新渲染时值不变化也会执行





#### 简单描述 JavaScript 中的事件循环。

js 事件分文  **宏任务(macro-task)**和**微任务(micro-task)**

到此做个总结，事件循环，先执行宏任务，其中同步任务立即执行，异步任务，加载到对应的的Event Queue中(setTimeout等加入宏任务的Event Queue，Promise.then加入微任务的Event Queue)，所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。

#### **DNS**

域名系统（服务）协议（DNS）是一种[分布式网络](https://baike.baidu.com/item/分布式网络/8951687)[目录服务](https://baike.baidu.com/item/目录服务/10413830)，主要用于域名与 IP 地址的相互转换，以及控制[因特网](https://baike.baidu.com/item/因特网/114119)的[电子邮件](https://baike.baidu.com/item/电子邮件/111106)的发送。

