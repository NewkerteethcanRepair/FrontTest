# **B/S 和C/S**

Brower/Server （浏览器）/服务器

Client/Server （客服端）/服务器

描述 一下浏览器输入地址后到整个网页呈现出来的工程

# **网络协议  之一 TCP/IP （普通人协议）**



tcp ip http

军方网络 其他非 tcp/ip协议

#### tcp 

主要负责数据发送，保证数据的完整性，和安全性

#### 三次握手

发送数据之前的

客户端 ： 报文  发送数据要求请求，

服务端： 得到请求，给结果给客户端

客服端：得到服务端的结果，

#### 四次挥手‘

 客户端：我的数据发送完了，我可以断开连接了吗？

 服务端:   你等会儿，我还有数据没有发送完，

 服务端： 好，我的数据发送完了，可以断开连接了。

 客户端：好的，我知道了，那我断开了

#### **http** 

http 和 https

https 安全性高



# **一次完整的http事务？（输入url后发生了什么） （b/s架构）**

dns域名解析：ip对应到一串字母   在DNS服务器 进行域名解析 对应的ip地址给浏览器 ，然后把真正的ip给服务器

版本2.0

也可以说

**1 dns 查询(dns域名解析)**

**2 建立TCP连接**

**3 发送http请求**

**4 服务端接收并处理请求**

**5 服务端返回响应结果**

**6 关闭TCP连接**

**7 浏览器解析HTML**

**TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据**



1发送请求到dns服务器

2域名解析

3 发送请求到用户访问的服务器

4 建立连接

5 发送数据

6关闭连接


![image-20200218101744179](C:\Users\newteethqaq\AppData\Roaming\Typora\typora-user-images\image-20200218101744179.png)

# **http**

特点

1.请于 现有 请求 才有响应

2.无连接，短连接

3 无状态 无记录 没有上一次记录

http 请求消息体

1. 请求行 ：请求方式 get post  请求路径，http协议
2. 请求头 浏览器版本 系统版本等
3. 空行
4. 请求体 真正要发生给服务端的内容 比如 用户信息 密码等

http 响应

1. 状态行 响应行： http 协议版本号，状态号码
2. 响应头   编码集，时间，压缩方式，cookie
3. 空行    
4. 响应体  服务端你真正要发送给客服端内容

状态码

- 2xx  成功
- 4xx 	前端出问题
- 5xx	后端出问题

***http模块***

​	端口， 就是通过ip地址 找到计算机， 利用端口 好可以找到计算机 对应的应用的程序，每一个应用程序都有唯一的端口号 范围 0—65535

## 



# **模板引擎**

art-template  是一个超快的国产 模块引擎

![image-20200220113942779](C:\Users\newteethqaq\AppData\Roaming\Typora\typora-user-images\image-20200220113942779.png)

![image-20200220114337581](C:\Users\newteethqaq\AppData\Roaming\Typora\typora-user-images\image-20200220114337581.png)

# **promise**

异步操作

new promise(function(resolve,reject){



})



promise 对象三种状态

- ​	pending:等待中
- ​	fulfilled: 已成功
- ​    rejected：已失败

# **async**

async function main(){

}

![image-20200221103912375](C:\Users\newteethqaq\AppData\Roaming\Typora\typora-user-images\image-20200221103912375.png)

es7用法

![image-20200221104301135](C:\Users\newteethqaq\AppData\Roaming\Typora\typora-user-images\image-20200221104301135.png)

![image-20200221104704526](C:\Users\newteethqaq\AppData\Roaming\Typora\typora-user-images\image-20200221104704526.png)

# **Node.js**

node.js 是一个基于 Chrome v8 引擎JavaScript运行时

运行时：运行环境

 Chrome v8 引擎：谷歌 研发的一个引擎

**浏览器内核**

1 渲染引擎

2 js 引擎

###### 发展历史

诞生于2009年 由ryan dahl 开发

2014 独立出了 io.js

**特点**

1.js运行环境

基于v8引擎

基于事件驱动非阻塞式 I/O (input/output)



#### **引入**

```
 require（"路径"）
```







#### 暴露

当前模块化，只有暴露出去的数据，其他模块才能访问

let b=2

module.exports.b=b;



fs操作

```
/ 1. 读取文件内容
// fs.readFile('../data/msg.txt', 'utf-8', function(err, data) {
//     console.log(1, data);
// });
// // 同步读取文件内容
// const data = fs.readFileSync('../data/msg.txt', 'utf-8');
// console.log(2, data);

// // 2. 写入文件内容(覆盖原内容)
// fs.writeFile('../data/msg.txt', '这是我新写入的内容', function(err) {});

// 3. 追加内容（保留原内容）
// fs.appendFile('../data/msg.txt', '这是我要追加的新内容', function(err) {});

// 4. 复制文件
// fs.copyFile('../data/msg.txt', '../data/newmsg.txt', function(err){});

// 5. 删除文件
// fs.unlink('../data/newmsg.txt', err => { });

// 6. 创建文件夹
// fs.mkdir('../public', err => {});

// 7. 删除文件夹
// fs.rmdir('../public', err => {});

// 作业：创建两个非空文件 a.txt 和 b.txt，将 a.txt 的内容拷贝到 b.txt 中，同时保留 b.txt 的原内容。

// 读取文件内容
// fs.writeFile("")
// 异步
// fs.readFile("./a.txt","utf-8",(err,data)=>{
//     console.log(data);
//     fs.appendFile("./b.txt",data,(err)=>{

//     })
// })

// 追加内容（保留原内容）

// 判断文件是否存在
// fs.access("./b.txt",(err)=>{
    
// })
console.log("sad");

// 10 判断是文件还是文件夹
// fs.stat("../fs", (err,stats)=>{
//     console.log(stats);
//     console.log(err);
   
    
// })
// 11重名
// fs.rename("../a.txt","./aa.txt",(err)=>{
//     console.log(err);
    
// })
```





# **环境搭建**

**命令 查看node.js 版本**

bash

node -v

- **打开终端**

**通过vscode**

1. cd 文件夹 

1. cd..返回
2. 直接点击文件 右键 有个 open in Teminal

![image-20200218112622461](C:\Users\newteethqaq\AppData\Roaming\Typora\typora-user-images\image-20200218112622461.png)

3 通过 node js文件名 执行代码

也可能通过 code running

./ 快捷键 获取到文件名

# **环境变量**

# **模块化**

Javascript规范：ECMAScript

Node.js 遵循 CommonJs规范

5.1模块

**CommonJs规范的特点：**

1. ​	每一个js文件都是一个独立的模块，所有代码都运行在模块作用域
2. 模块可以多次加载

**module对象**

module.exports

用于当前模块内定义对外接口

module.exports.num1=num;

然后下一个js 就 可以 require('./a.js')  

require 命令用于读取并执行一个js文件，返回改js文件的module.exports 对象

### **Node内置对象 模块**

**1.fs 文件系统**

const fs =require("fs");

const myPath=''

//1 获取 path

**2.stream流**



1.获取path

\\转义符 再转义

把\\

- basename() //返回路径最后一部分
- path.dirname() //返回路径目录(文件名)
- extname:返回文件的扩展名 
- 组合 path   path.join("public","a.js") 相对路径
-  path.resolve("a","b") 绝对路径

用 path.format 最好 组合  ({

dir:"c:\\\users\\\xxx\\\xxx"  //目录地址

base："xx/txt"

})

path.parse 拆分

![image-20200219121151097](C:\Users\newteethqaq\AppData\Roaming\Typora\typora-user-images\image-20200219121151097.png)

# **os**

# 

主要是看内核信息





# **npm**

包管理工具，npm跟随node.js 一起下载安装的。

​	用户可以从npm服务器上下载包

​	用户可以将自己编写的包上传到npm服务器

国内淘宝镜像百度

**常见命令**

​	1初始化 npm init        

​	2下载包 npm install 或者 npm i +包名

​	3 下载package.json 下载所有依赖包   npm i

​	4 卸载 npm uninstall

# **express** 应用程序生成器 （web开发框架） 

基于 [Node.js](https://nodejs.org/en/) 平台，快速、开放、极简的 Web 开发框架 使用 Express 可以快速地搭建一个完整功能的网站

**Koa/Koa2 也是web开发框架**

init可以生成 但是 还是要自己创建

##### **步骤**

1 全局 安装生成器   

```
npm i express-generator -g
```



2 express 项目名称  

3 npm i 如下图！！！！

4 默认启动 npm start

5 在app.js 更改启动命令 (最后一行 )

```
app.listen(8080,()=> console.log("8080端口 成功"));
```



6 启动项目 node app.js 

![image-20200221121809442](C:\Users\newteethqaq\AppData\Roaming\Typora\typora-user-images\image-20200221121809442.png)





npm start 启动

可以通过 改代码 用 node  ./xxx 启动



npm install express -generator -g

express 项目名称 

项目内下载包 npm i 首先项目中要有package文件

index.html可以省略不写，其他名字不行

新插件 npm i nodemon -g 

**node 项目热加载差价**

下载插件

npm  i nodemon -g

启动项目

nodemon app.js  就可以自动更新，无需所动重新启动

永久使用国内镜像

## **项目结构**

静态资源（前端代码） 放在 public 里面 

后端代码   除public的所有文件 只能在node。js 等后台环境运行 

app.js 项目入口文件

routes     表现层 ：代码   匹配前端请求 接收 前端发送至后端的数据

service    服务层 ：负责逻辑业务处理    连接表现层和持久层 并 负责两者之间的数据逻辑业务处理和传递

dao   (Data Access Object)      持久层：负责 数据库江湖          需要models数据模型 和   连接数据库 database.js  加载所有model文件

database.js  1 负责连接  2 加载所有model文件 3  在 app.js引入

​		

# **数据库**MongoDB

database  存储和管理数据的仓库

# 分类

关系型数据库  mysql oracle

菲关系型数据库 mongoDB

配置环境变量

查看dbs   

show dbs

db指向当前正在操作的数据库

新建数据库

查看当前数据库所有集合

```
show collections
```



users集合  添加

```
db.users.insert({

"phone":"123",

"pwd":"123"

})
```

查看某个集合中的所有数据

```
db.users.find().pretty()
```







可视化图形工具 很多 自己百度  Navicat 等

# **mongoose**

是 node.js 提供的一个便捷操作 mongo的库 工具

安装 npm i mongoose



然后express app.js 引入

require("./dao/database");

使用

连接数据库 

创建数据结构  --- 多表关联

创建数据模型 

mongoose.model(数据模型名称，数据结构名称，集合名称)

mongoose.model("user",数据结构名称) //第一个和第三个一样省略简写

通过模型操作 数据库

1. 查询  find 精准查询 模糊查询  分页 limit skip    多表关联查询 populate
2. 新增 create    
3. 修改 updateOne 
4. 删除 deleteOne     deleteMany



j一个插件 和服务器 与数据库连接起来



条件查询 find(条件,(err,data)=>{

})

插所有 find((err,data)=>{

})

新增

mongoose.model("usersModel").create(新增数据,(err,data)=>{

});

删除

mongoose.model("usersModel").deleteOne(删除数据,(err,data)=>{

});

删除多个

mongoose.model("usersModel").deleteMany(删除数据,(err,data)=>{

});

修改

mongoose.model("usersModel").updateOne(查询条件,修改数据,(err,data)=>{

});

![img](file:///C:\Users\newteethqaq\Documents\Tencent Files\862774887\Image\Group\Z@WO~_$F%VL(214{YW`5XQS.png)

# 后端三层结构**

前端 <-表现层 服务层（判断处理数据）  持久层-》数据库

module.exprots.a=1;

module.exprots={

a:1,

b:2

};









# 1. RESTful

```js
url: '/students/deleteOne'
type: 'POST'
```

restful

​		资源名称（/students)

​		资源名称+id（列如：/students/01)

​		

```js
url: '/students'
type: 'DELETE'
```

新增 学生

删除 班级

### 1.1 请求类型

http 请求包含的请求类型：

- GET（获取）
- POST（新增）
- PUT（修改）
- DELETE（删除）

```js
url: '/classes',
type: 'POST'
```

# 文件上传下载



input type=“file”

要 下载 npm i  mulptixxx

# 2.1 同源策略 跨越

同源策略是浏览器端的一个安全策略。

```
http://192.168.1.11:3000/index.html
```

- 协议：例如 http
- IP：例如 192.168.1.11
- 端口：例如 3000

### 2.2 跨域的定义

当一个 URL 请求的协议、IP、端口三者中任意一个与当前页面的 URL 不同，即为跨域。

跨域问题的出现就是由于【浏览器同源策略】的限制。

script link img 天生就支持跨域的。

### 2.3 解决跨域的办法

- jsonp：

  - 原理是利用了 script 标签天生就支持跨域的特点，因此 jsonp 的方式只能解决 get 请求的跨域。

  ```js
  $.ajax({
      url: 'http://localhost:3000/students/getAll',
      data: {
          currentPage: pageData.currentPage,
          pageSize: pageData.pageSize
      },
      dataType: 'jsonp',   // 解决 get 的跨域问题
      success(msg) {
          const html = template('tpl', msg);
          $("tbody").html(html);
          $("#currentPage").val(pageData.currentPage);
          pageData.pages = msg.pages;
      }
  })
  ```

  ```js
  // 服务端返回消息使用  res.jsonp
  router.get('/getAll', async (req, res) => {
      res.jsonp(await getAll2(req.query));
  })
  ```

- cors：

  ```js
  // CORS：设置允许跨域中间件
  var allowCrossDomain = function (req, res, next) {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "X-Requested-With,Origin,Content-Type,Accept");
    res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");
    res.header('Access-Control-Allow-Credentials', 'true');
    next();
  };
  app.use(allowCrossDomain); // 使用该中间件
  ```

- 代理服务器

 服务器与服务器是不会跨越的      



对象的键是变量的话 +[] 就好了 





# **身份认证**

1 jwt/localStroage

2 session cookie

npm i express -session-file-store



# 身份认证

1. jwt
2. session cookie

### session cookie

**下载**

使用工具 express-session 和  session-file-store

```bash
npm i express-session session-file-store
```

**配置**

```js
// app.js
const session = require('express-session');
const FileStore = require('session-file-store')(session);

app.use(session({
  name: 'currentUser',
  secret: 'secret',
  store: new FileStore(),
  saveUninitialized: false,
  resave: false,
  cookie: {
    maxAge: 1000 * 60 * 2 // 2分钟
  }
}));
```

![image-20200227115824906](C:\Users\Jaelyn\AppData\Roaming\Typora\typora-user-images\image-20200227115824906.png)

![image-20200227115842576](C:\Users\Jaelyn\AppData\Roaming\Typora\typora-user-images\image-20200227115842576.png)

**登录成功保存用户信息**

```js
const data = await mongoose.model("usersModel").find(req.body);
if (data.length > 0) {
    req.session.regenerate(function () {
        req.session.loginUser = data[0].phone;
        res.send(true);
    });
} else {
    res.send(false);
}
```

**判断用户是否登录**

```js
router.get('/isLogin', (req, res) => {
	const phone = req.session.loginUser;
	if (phone) {
		res.send({ isLogin: true, phone });
	} else {
		res.send({ isLogin: false });
	}
})
```

**退出登录**

```js
router.get('/logout', (req, res) => {
	req.session.destroy(function() {
		req.session.loginUser = null;
		res.clearCookie('currentUser');
		res.send(true);
	})
})
```

**session 是服务端的，cookie 是前端的。**
**我们数据保存在服务端的 session 里，保存成功后，会有一个 session 的标记返回到前端，然后保存在 cookie 里**
**你可以理解成 sessionid**
**session 保存成功后，会返回一个 sessionid 给前端，前端把这个 sessionid 保存在 cookie 里**

**sessionStorage和localStorage是html5  本地化存储**

# **webpack**

## **ES6前端模块化**

## 友情赠送知识点 —— ES6 前端模块化

js 之间相互独立

```html
 <script src="./index.js" type="module"></script>
```

- 暴露：export
- 引入： import {} from "路径"



- 暴露：export default（只暴露一个）
- 引入：import ... from "路径"







1. 安装



前两个 grunt 和 gulp 打包 现在过时了

node.js

webpack-cli



```
npm i webapck webpack-cli -g
```

### j**基本使用**

webpack 是一个 基于node.js  因此需要一个package.json文件

```
npn init -y
```

# **执行 webpack命令**

```
开发环境（不压缩）webpack src/index.js -o dist/bundle.js --mode=development
s生产环境(压缩)   mode=production 
```



webpack 默认就能打包 编译的js文件，能够将es6或更高版本的的 一些语法转换成浏览器能够识别的语法

还能够压缩



入口和出口配置

mode 配置

loader 



下载 css loader

npm i css-loader style-loader

打包less

less

less-loader

npm i less less-loader

img

#### loader

由于默认情况下，webpack 只能打包 js 文件，当遇到其他格式的文件时，webpack 不知道怎么去处理。所以这个时候就需要我们手动的去设置一些 rules（规则），来告诉 webpack，遇到不能处理的文件时，该怎样的找对应的 loader。

默认情况下 webpack只能打包js文件· 当遇到其他格式的文件时，webpack不知道怎么去处理。所以这个时候就需要我们手动的去设置一些rules 来告诉webpack 遇到不能处理的文件， 如果解决的 loader(比如css级不识别)

## 1. 打包 CSS

下载 loader

- style-loader
- css-loader

配置 loader

```js
module: {
    rules: [
        {
            test: /\.css$/,
            use: ['style-loader', 'css-loader']
        }
    ]
},
```

## 2. 打包 less

下载 loader

- less
- less-loader

## 3. 打包 CSS 中的图片

- file-loader
- url-loader

hash

# **plugins**

loader 主要是针对各种类型的文件

plugins 并不是操作单个文件，而是对整个构建过程起作用

html-webpack-plugin



插件2

clean-webpack-plugin

项目内安装 webpack

npm i webpack webpack -cli

### 1. html-webpack-plugin

下载 

```bash
npm i html-webpack-plugin
```

引入

```js
const HtmlWebpackPlugin = require('html-webpack-plugin');
```

配置

```js
plugins: [
    new HtmlWebpackPlugin({
        template: './src/index.html'
    }),
],
```

启动

启动报错



解决办法

```bash
npm link webpack
```

### 2. clean-webpack-plugin

```js
plugins: [
    new CleanWebpackPlugin(),
],
```



# **devServer**

配置开发中的服务功能

npm i webpack-dev-server

启动

```
webpack-dev-server 会报错 解决方法如下
```



在package.json配置

```
"script":
	{
	"test":"echo \"Error: no test specific"
}
```



然后使用这个命令

npm run dev

# **VUE**

**库和框架**

库是零件， 框架

1. 库用三个字概括就是小而巧，只提供了特定的API，可以很方便地从一个库切换到另外一个库，而代码无需做很很大的修改；
2. 框架用三个字概括就是大而全，框架提供了一整套的解决方案，故在某个项目中间想从一个框架转到另一个框架，代码需要做很大的改动。

库 jquery  

框架 vue 2014

 react  2013 

angular 2009

vue 是一套用于构建用户界面的渐进式框架

## **MVC, MVVM**



MVVM means model <=> view <=> model view , that’s means when view change, both mv and m can auto change or not change depend on you， （体现双向数据绑定）

双向数据绑定



# Vue 实例对象

```
var vm=new Vue({
    // 对象 
    常用属性  
    el 挂载目标（元素节点 选择器）
    data 数据
    对象  data:{msg:"hello"} 在组件内不能使用 不支持该类型（因为 组件没有实例  组件在外面vue.component() 使用data()函数 每次return 返回 都是独立的)
函数 data(return{msg:"hello"})

   computed(计算属性) 对象 可以检测数据变动
   watch:监听 侦听属性    对象 作用：可以检测数据变动 能用computed都用它，除非 有额外特殊操作 则用watch
   methods(方法)
   components(局部组件) 对象
})；


console.log(vm);

```

**data**

data 属性值分两种 ： 

对象

函数 且函数返回值必须是对象

#### el**

elment el 属性用于定于Vue实例的挂载目标，el的值是一个css选择器

{{}}  v-text ，

指令

v-show : true flase , 显示或者不显示

v-bind ：动态绑定 可以简写 :  作用域 标签上面的属性 能够动态

v-model: 作用域表单 主要作用域表单

   双向数据绑定

#### （mvc）    model(数据) view controller  数据的改变触发页面更新 

#### （mvvm）model view viewmodel   双向改变

![image-20200302120221913](C:\Users\newteethqaq\AppData\Roaming\Typora\typora-user-images\image-20200302120221913.png)

视图更改 数据自动更新       数据更改，视图自动更改



**computed 计算数学**

**能够通过计算 处理数**据





**watch 监听属性**

**能够类似 click 之类的**



**class和style**

#### **数据渲染**：

v-html  都是用在开始标签上

v-text

##### **模板语法**：

只能用在标签内部

##### css和style：

对象 数组

##### **条件渲染**

v-if

v-if-else

v-else



##### **列表渲染**

v-for

#### **事件**

绑定事件 v-on   或者@   

methods 设置 事件方法

事件修饰符

```
event.preventDefault()` 或 `event.stopPropagation()
```

为了解决这个问题，Vue.js 为 `v-on` 提供了**事件修饰符**。之前提过，修饰符是由点开头的指令后缀来表示的。

- `.stop`
- `.prevent`
- `.capture`
- `.self`
- `.once`
- `.passive`

@click.prevent

在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符：

```
<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->
<input v-on:keyup.enter="submit">
```

你可以直接将 [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。

```
<input v-on:keyup.page-down="onPageDown">
```

在上述示例中，处理函数只会在 `$event.key` 等于 `PageDown` 时被调用。





**vue很多操作和以前更改dom 不同， 基本是该数据 来该样式和属性！！** 不提倡改dom元素



**filter**

和map()类似，Array的filter()也**接收一个函数**。和map()不同的是，filter()**把传入的函数依次作用于每个元素**，然后根**据返回值是true还是false决定保留还是丢弃**该元素。



**对于引用类型的地址**

在methods 里面修改数组 vue 识别不了，图层不会更新



Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：

- `push()`
- `pop()`
- `shift()`
- `unshift()`
- `splice()`
- `sort()`
- `reverse()`

这些操作也能监听到，

#### 表单处理：

双向数据绑定 v-model 输入框

​										  文本域 textarea

​										  单选按钮 复选框  下拉列表

​					

#### 指令

v-show  和 v-if 区别 v-show 只是 让display none or true 而 v-if 单纯判断，加不加载数据

v-html

v-bind   

# **组件** 

在html css时 称为盒子，

组件：包含样式功能的 一个整体

### 全局组件

Vue.component

```
Vue.component("yourname",{
template:`
<div> </div>
`
only one root element

})
```

#### **局部组件**

{在newvue 里面 的components：{}}







组件的使用:在挂载目标中使用

组件之间可以嵌套使用

#### **props 单向数据流**

只能从**父传子**



props的类型 数组

​						对象 props的验证

官方不建议修改props    （会报错

不能修改基础类型数据

引用类型只要不修改地址都无所谓

#### **自定义事件** 

**子传父**

$emit( )

子组件调用父组件的方法

​	**子组件调用父组件的方法**

​	**子组件传值给父组件**



# **单向数据流**

#### ***props**

3种情况

**1 子组件通过props接收到的父组件传递的数据后，不做任何的额外处理**

父组件数据发送改变 子组件会同时改变(不区分数据类型)

**2 将数据交给data处理**

data函数只进行一次，所以子组件data中的数据不再受父组件数据的影响

​	注意：当父组件的传递的数据类型为引用数据时，由于父子组件公用的数据用同一栈里的引用地址，因此会父会影响字

如果data不受影响 需要 改变他的引用地址（新建一个array或者对象 去赋值给他）

**3 交给 computed:** 

当 依赖的源数据 不会改变时，不会反复执行，如果改变了才执行（没改变都是读取缓存中的数据，一旦数据变化，computed会重新计算，也就是说 computed中的所对应的函数会重新执行 [...this.array]



**1修改props:官方不建议修改props **    

修改基础数据类型时，可以修改，但会报错

修改复杂数据类型时，数据可以成功修改，并不会报错 共用同一个引用地址

而我们修改子组件props 。只修改了数据的值，并没有修改数据的引用地址，所以vue不会检测到

**子组件修改基于props的data**

理论上说，data接收到props之后，data就不会再受props影响，同时修改子组件的data也不会影响父组件，

但是，如果data接收的props 是引用数据类型，则父子组件共用同一个引用地址，则还是会影响

**子组件修改与props的computed**

computed 默认情况下 只有getter,没有setter，所以不能修改

```
computed:{
完整写法
comNum：{
get：function(){
return this.num;
}
自己写set 
set:function(newvalue){
  this.num=newvalue;
}

}
但是没卵用 特殊情况下，我们可以给computed添加setter
```

# **总结**

**1.简单数据类型**

1. ​	如果希望子组件受父组件影响，子组件可以选择直接props接收，或者    基于props的computed接收。
2. ​	如果不希望子组件被父影响，子组件可以选择props 的data接收。
3. ​	如果子组件希望能够改变数据，子组件可以选择基于props的data接收

**2.复杂类型数据**

1. 如果希望子组件受父组件影响，子组件可以选择直接props接收，或者基于props的computed接收。
2. 如果不希望子组件被父影响，子组件可以选择props 的data接收。同时改变引用地址（给data一个新的引用地址）
3. 如果子组件希望能够改变自己的数据，同时不改变父组件。子组件可以选择基于props 的data接收，同时给data 一个新的引用地址。
4. 如果子组件希望能够改变自己的数据，同时改变父组件数据,子组件可以选择直接props接收 ，但不给新的引用地址。





| 数据类型 | 父组件修改数据是否影响子组件 | 子组件是否修改数据 | 子组件修改数据是否影响父组件 | 子组件内是否给新地址 | 子组件接收父组件数据的方式 |
| -------- | ---------------------------- | ------------------ | ---------------------------- | -------------------- | -------------------------- |
| 基础类型 | 是                           | 否                 | -                            | -                    | props、computed            |
| 基础类型 | 否                           | 否                 | -                            | -                    | data                       |
| 基础类型 | 是                           | 是                 | -                            | -                    | -                          |
| 基础类型 | 否                           | 是                 | -                            | -                    | data                       |
| 引用类型 | 是                           | 否                 | -                            | 否                   | props、computed、data      |
| 引用类型 | 是                           | 否                 | -                            | 是                   | computed                   |
| 引用类型 | 是                           | 是                 | 否                           | -                    | -                          |
| 引用类型 | 否                           | 否                 | -                            | 是                   | data                       |
| 引用类型 | 否                           | 是                 | -                            | 是                   | data                       |

# 生命周期

**初始阶段**

beforecreate

created  向后端发送请求

**运行阶段**

beforeMount

mouted 向后端发送请求

beforeUpdate ：执行多次 只要更新

updated   执行多次 只要更新

**销毁阶段**

beforedistory

destroyed 

# **跨越**

新建一个vue.config.js



module.**exports**={

  //*跨越*

  devServer:{

​    proxy:"http://localhost:300-"

  }

}



# **Vue项目中组件单文件

#### vue 脚手架 Vue CLi



**1配置Vue项目的跨域请求**

在项目根目录创建一个 vue.config.js文件,文件内容如下：

```
module.exports={
	devServer:"http://localhost:xxxx" //需要访问的服务器地址
}
```

配置后需要重置服务器

##### 2下载axios**

```
npm i axios
### **新的ajax交互**axios



根目录 npm i axios
```

##### **3使用axios**

​	1引入axios

​	import axios from "axios";

**组件中使用axios**

​	get 

```
axios
.get("/students",{params:{_id:1}}).then(res=>{
	
})
```

​	post



``` 
.post("/students",{_id:1}).then(res=>{ //直接写参数
	
})
```

put

	.post("/students",{data:{_id:1}).then(res=>{ //直接写参数
	})

})

delete

.post("/students",{_id:1}).then(res=>{ //直接写参数
})??/





# **插件 detected Vue**

# 路由 Vue router

作用：用于分配请求

#### 安装方法

1安装 npm i vue -router

2在cil 工具创建 项目时选择router

#### 配置



路由初始化

配置路由  路径的设置

​					对应组件的配置

路由出口：

<router-view>



#### **跳转**

````
const routes = [

 {

  path: '/studentslist/:带参数或者不带',

  name: 'studentslist',

  component: studentslist

 },
````

标签跳转， 路径跳转 

方法1router-link    to  tag   active-class



如果当前router-link的tag不是a的话（官方文档中说明：默认为a，可以通过tag改变渲染后的标签），那么就会往自己的子元素（组件）找，找到的第一个就会把一些属性及时间覆盖过去。
 所以此时事件是被阻止了。个人看法：因为router-link的作用是单纯的路由跳转，如果不阻止事件的话，也许会有很多坑，所以作者干脆阻止了其他事件的触发。

方法2 this.$router

push

 replace   

go()





#### 传参 

##### 传递传参

1 方法1 路径传参

to"/xxxx/001"

![TIM图片20200309092833](C:\Users\newteethqaq\Pictures\Saved Pictures\TIM图片20200309092833.jpg)



![TIM图片20200309092857](C:\Users\newteethqaq\Pictures\Saved Pictures\TIM图片20200309092857.png)

2通过params name 传参 只能是name

<router-link  :to="{name:'xxxx',params:{id:001}">

3通过 query传参 都可以

<router-link :to="{path:'/test',query: {name: id}}">跳转</router-link>(id是参数)

:to="{path:'/xxxx/',query:{id:001}"

:to="{name:'xxxx',query:{id:001}"

1. 然后 通过 mouted  接收参数
2. 里面 this.$route.params.参数名字
3. 在 router index.js 
4. path : xxxx/:id
5. 再index.js 设置props :true

##### 接收参数

1props true；

2 this.$route   

params

query





获取参数 再 mounted

 里面 this.$route.params.参数名字

再index.js 设置props :true

  **this**.$router.push("./studentslist"); 跳转 并且记录

  **this**.$router.reaplace("./studentslist"); 跳转 不记录 不会返回

**this**.$router.go(1); -1 返回一个 1 前进 一个

 router-link 默认是a标签 

< router-link  tag="指定标签" to="router地址"   active-class=" 当选中时的css样式">





# 嵌套路由

#### 路由配置

children

#### 路径设置

to="/system/studentslist"



# 导航守卫

#### **全局**

beforeEnter()

#### **路由独享**

**beforeRouteLeave** 爽！

 **beforeRouteLeave**(to, from, next) {

  // *...*}

#### 组件独享

beforeRouteLeave

eg:确定要离开吗？



# **状态机** vuex

是一个专门为 vue.js 应用程序 开发的装药管理模式

状态管理应用

state  驱动应用的数据源

view	以声明方式将state 映射到视图

actions 响应在view上的用户输入导致的状态变化

本质上引入store 存储数据

安装

npm install vuex

**修改store里面 的数据 唯一方法就是 提交 mutation**

store

- ​	 state  类似于data
- ​	gettter 类似于 computed
- ​	mutations  类似于methods
- ​	actions 类似于methods 主要用于异步
- ​	modules 类似于模块化，把store拆分成小的模块

##### ****不用辅助函数

this.$store.state

this.$store.getters

##### **辅助函数***

**节约代码**

import {mapState mapGetters} from "vuex"

##### **module化**

**import** { createNamespacedHelpers } **from** "vuex";

const { mapState, mapMutations, mapActions } = **createNamespacedHelpers**(

 "students" //模块名

);



module:分工成模块

##### ref相当于 绑定id 

然后 this.$refs.id.value =获取到指定input 的value



<style scoped> 只作用于当前 的组件样式

# elementUl

进入项目根目录

下载 vue add element