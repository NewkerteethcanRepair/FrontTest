###### 面0试

###### 题整理

###### 1.React / Vue 项目中，列表组件中key作用

```
答：

目的：key是给每一个vnode的唯一id，可依靠key，更准确，更快的拿到旧Vnode中对应的vnode节点，从而更新节点。

vue和react都是采用diff算法来比较新旧虚拟节点（比较只在同层级进行, 不会跨层级比较），从而更新节点。

- 当新虚拟节点无key时，会采用遍历查找的方式去找到对应的旧节点。
- 当对比无结果时，则认为是新增节点。
- 当对比有结果时，就会更改对应相关节点完成渲染。

但是，并非带key就能加快渲染。因带上唯一的key会增加开销（关键：能保证组件的状态正确），所以在不带key情况（节点可进行复用，此时省去操作DOM的开销），但此只适用于简单的无状态组件的渲染。
```



###### 2.Vue 的组件中 data 为什么不能是对象？

```
答：

因对象是引用类型，组件可能会被多个实例同时引用，这可能导致多个实例共享一个对象，其中一个组件改变data属性值，其它实例也会受到影响。

而data是函数的情况下，每次函数执行完毕后都会返回一个新的对象，这样每个组件都会维护一份独立的对象（data），而不会相互影响。
```



###### 3.React 中函数组件和类组件区别？

```
答：

函数组件又称为无状态组件，即无状态管理，后面可通过hook实现。

具体区别如下：
```

| 区别               | 函数组件 | 类组件 |
| ------------------ | -------- | ------ |
| 是否有 `this`      | 没有     | 有     |
| 是否有生命周期     | 没有     | 有     |
| 是否有状态 `state` | 没有     | 有     |

```
注意：两者组件名均需以大写字母开头且组件的返回值只能有一个根元素。
```



###### 4.JavaScript 中包含哪些数据类型？

```
答：

分为基础数据类型与引用数据类型。

基础数据类型：number、string、boolean、null、undefined、symbol

引用数据类型：Object(Function、Array、Date等)
```



###### 5.cookie、localStorage 和 sessionStorage 区别？

```
答：

共同点：都是保存在浏览器端、且同源的。

区别： 
1、用法上不同。
cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。
sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可限制cookie只属于某个路径下。

2、存储大小限制上的不同。
cookie数据不能超过4K，同时因每次http请求都会携带cookie、故cookie只适合保存很小的数据，如会话标识。
sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

3、数据有效期不同。
sessionStorage：仅在当前浏览器窗口关闭之前有效；
localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；
cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 

4、作用域不同。
sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；
localstorage、cookie在所有同源窗口中都是共享的；
```



###### 6. MVVM与MVC 区别？

```
答：

MVVM：即Model-ViewModel-View，模型至后端传递的数据，视图是所看到的页面，视图模型是mvvm模式的核心，它有两个方向：
一、可将模型转化为视图，就是将后端传递的数据转化成所看到的页面，实现方式是：数据绑定。
二、可将视图转化为模型，即将所看到的页面转化为后端的数据。实习方式是dom事件监听。这两个方向都实现的，就叫做双向数据绑定。

MVC：Model-View-Controller。 使用MVC的目的就是将M和V的代码分离。MVC是单向通信。即View跟Model，须通过Controller来承上启下。 

两者最大区别：MVVM实现了View和Model的自动同步。
```



###### 7.什么是 Virtual DOM？

```
答：

即虚拟节点，是原生dom在内存中的js对象映射，但不是完全复制，比真实dom节点在属性上简化，即更加轻量级，也可理解为是数据和原生dom的一层缓存。常见于React与Vue中，在触发更新好，通过diff算法，对新旧虚拟DOM对比，来完成对应DOM渲染改变。

出现的目的及其意义：由于DOM操作是非常昂贵的，但js的运行效率非常高。故用js对象模拟dom结构，来提高页面渲染速度，提高性能。
```



###### 8.React与Vue 中如何实现实现父子组件、兄弟组件之间的传值？

```
答:
React
1.父传子：父组件通过属性的方式传递参数，子组件通过props来接收父组件传递过来的参数。
2.子传父：父组件通过属性的方式传递自定义函数，子组件通过this.props.事件名(参数)的方式向父组件传递参数。
3.兄弟组件：两个兄弟组件之间会有一个共同的父组件，结合上述父子传值的方式来实现兄弟之间的传值的，即先其中一个子组件（兄弟组件）向父组件传值，然后父组件接收到这个值之后再将值传递给另外一个子组件（兄弟组件）。
Vue
1.父传子：与React一样
2.子传父：父组件通过属性的方式传递自定义函数，子组件通过this.$emit('事件名'，参数)
```



###### 9.Vue 中 watch 和 computed 的区别是什么？

```
答：

1.定义及使用上：

watch(监听属性)：监听相应数据变化而执行相应操作完成渲染更新，当要在数据变化时执行异步或开销较大的操作时使用。
computed(计算属性)：为了模板中的表达式简洁，易维护，将复杂的运算应用计算属性书写。

2.触发方式不同：

计算属性是声明式的描述一个值依赖了其他值，依赖的值改变后重新计算结果更新DOM。
属性监听的是定义的变量，当定义的值发生变化时，执行相对应的函数。
```



###### 10.在React的事件中，多次调用setState方法，render 执行几次

```
答：

一次。

原因：与React执行机制有关。

具体描述：React为了提高整体的渲染性能，会将一次渲染周期中的state进行合并，在这个渲染周期中对所有setState的所有调用都会被合并起来之后，再一次性的渲染，这样可以避免频繁的调用setState导致频繁的操作dom，提高渲染性能。

具体的实现理解，可简单理解为React中存在一个状态变量isBatchingUpdates，当处于渲染周期开始时，这个变量会被设置成true，渲染周期结束时，会被设置成false，react会根据这个状态变量，当出在渲染周期中时，仅仅只是将当前的改变缓存起来，等到渲染周期结束时，再一次性的全部render。
```



###### 11.简单描述 Vue 2.x 中响应式的原理。

```
答：

官网原话：当你把一个普通的 JavaScript 对象传入 Vue 实例作为 `data` 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 [getter/setter]

基本原理粗理解：1.创建Vue实列——2.自定义Js对象作为data 属性时——3.Vue内置的遍历data的方法预先会将传入的每个属性进行遍历，并将遍历的的每个属性通过Object.defineProperty（'对象名'，属性，属性描述），类似于对该对象的该属性添加setter/getter等方法——4.（大致可理解为）在改变data某个属性时，在一定条件下会触发属性内遍历内置的set方法，set方法里面就会有 触发页面重新渲染的方法。

注：get -给属性提供getter方法，默认为undefined，访问该属性时，该方法会被执行，默认参数为this对象；
   set - 给属性提供setter方法，默认为undefined，属性值修改时，会执行该方法，唯一参数为新的值；
   
详细：https://www.cnblogs.com/fmixue/p/12022296.html
```



###### 12.简单描述 JavaScript 中的事件循环。

```
答：

前提：javascript是单线程的语言，由于异步的特性，易实现非阻塞，故在JS中对于耗时的操作或者时间不确定的操作，采用异步操作(关键点)。

事件循环---event-loop

javascript事件分为宏任务(macro-task)和微任务(micro-task)，事件的执行顺序：先执行宏任务，再微任务。

而任务又分为同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。

异步过程：主线程发起一个异步请求，异步任务接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时异步操作开始执行；执行完成后通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)

强调：一个异步过程包括两个要素：注册函数和回调函数，其中注册函数用来发起异步过程，回调函数用来处理结果。

详解：https://www.cnblogs.com/xiaohuochai/p/8527618.html
```



###### 13.重绘与回流

```
答：

概念：
每个页面都至少发生一次回流，也就是页面第一次加载时。
当渲染树中的一部分或者全部因为元素的尺寸、布局、隐藏等改变而需要重新构建时，这时会发生回流。
在回流时，浏览器会使渲染树中受到影响的元素部分失效，并重新绘制这个部分的渲染树，完成回流以后，浏览器会重新绘制受到影响的部分元素到屏幕中，这个过程就是重绘。

发生回流的情景
1、添加或者删除可见的DOM元素时
2、元素的位置发生改变
3、元素尺寸改变
4、内容改变
5、页面第一次渲染时
```



###### 14.什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求吗？

```
答：

跨域：当一个 URL 请求的协议、IP、端口三者中任意一个与当前页面的 URL 不同。
使用原因：
跨域问题的出现就是由于【浏览器同源策略】的限制。目的是为了安全,如果没有同源限制,在浏览器中的cookie等其他数据可以任意读取,不同域下的DOM任意操作,ajax任意请求其他网站的数据,包括隐私数据。
解决方式：
1.jsonp：原理是利用了 script（script link img天生就支持跨域的） 标签天生就支持跨域的特点，因此 jsonp 的方式只能解决 get 请求的跨域。
2.CORS：设置允许跨域中间件
3.代理服务器

注意：同源策略是浏*览器端*的一个安全策略。
```



###### 15.什么是变量提升？什么是暂时性死区？

```
答：

变量提升：JavaScript在执行代码的时候会有一次预编译，预编译会将要使用的变量提前进行定义，并赋予初始值，即undefined。局部变量会在预编译的时候在函数顶部进行声明。而全局下变量会一直存在。

暂时性死区(TDZ):由于js变量声明提升的机制，在let/const变量定义之前，是不允许使用该变量，包括同名的全局变量，不然会出现TDZ，并报引用错误。

```



###### 16.== 和 === 的区别是什么？

```
答：== 存在隐事转换 用于判断数据值是否相等，而===判断数据类型和值是否相等。
```



###### 17.如何正确的判断 this？箭头函数的 this 是什么？

```
答：

方法调用中谁调用 this 指向谁
全局作用域或者普通函数中 this 指向全局对象 window。（在严格模式中是undefined。）
在构造函数或者构造函数原型对象中 this 指向构造函数的实例
call谁就是谁，apply谁就是谁，bind谁就指向谁，其实bind就是通过call和apply实现的

普通函数中：this的指向只有在函数执行的时候才能确定this指向，this的最终指向的是离它最近上一级调用它的对象。
箭头函数中：箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定。它的this指向在定义的时候继承自外层第一个普通函数的this。（无arguments属性，无new）

```



###### 18.new 的原理是什么？通过 new 的方式创建对象和通过字面量创建又什么区别？

```
答：new的原理：创建一个新对象，该对象会被执行[[原型]]连接，将构造函数的作用域赋值给新对象，即this指向这个新对象，如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。

区别：字面量创建对象，不会调用 Object构造函数, 简洁且性能更好;
new Object() 方式创建对象本质上是方法调用，涉及到在proto链中遍历该方法，当找到该方法后，又会生产方法调用必须的 堆栈信息，方法调用结束后，还要释放该堆栈，性能不如字面量的方式。
通过对象字面量定义对象时，不会调用Object构造函数。
```



###### 19.原型是什么？

```
答：

在创建函数时，js会创建一个对应的原型对象，该对象包含了js内置的属性和方法，函数可通过原型链继承该原型方法。
关系：通过prototype指向该原型，原型通过自身constructor指向函数。
```

###### 20.call、apply、bind 作用是什么？区别是什么？

```
答：

call和apply都可以用来改变函数里的this指向，改变函数运行环境；
call(obj,1,2,3,)从第二个参数开始有多个参数，用来代表函数的实参；
apply(obj,[1,2,3])第二个参数是一个数组，数组中的每一个元素对应一个实参；
bind(obj,1,2,3,)();

三者区别：
apply,call是直接执行函数调用，bind是绑定，执行需要再次调用。
apply和call区别：apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表。
```



###### 21.React 中 Component 和 PureComponent 的区别是什么？

```
答：

主要的区别：对于触发更新渲染DOM的条件是否相同。

Component：setState状态更新都会引起dom渲染

PureComponent：是对于shouldComponentUpdate的优化，提高了性能，就是当props或者state改变时,会引起dom重新渲染,这里值的注意的是，当state为数组，对象等引用类型的时候，如果引用没有发生改变，它会认为state是没有发生改变的，也就不会重新渲染。当引用发生变化Component和PureComponent都会引起重新渲染。

注意：

继承PureComponent时，不能再重写shouldComponentUpdate，否则会引发警告
继承PureComponent时，进行的是浅比较，也就是说，如果是引用类型的数据，只会比较是不是同一个地址，而不会比较具体这个地址存的数据是否完全一致
此外,React.PureComponent 的 shouldComponentUpate() 会忽略整个组件的子级。请确保所有的子级组件也是”Pure”的

```

###### 22.数组去重

```
答：

es5之前，1.可通过for循环嵌套比较，再用splice去除
        2.创建新数组，for遍历旧数组每个值，用与新数组每个值比·			较，无则push进去。可用newArr.indexOf 或者some 方		  法比较。
        3.排序相邻比较，先排序，for循环与下个值比较，
        
es6之后，有了set类数组，其自带去重功能 可直接装换成Set数组， let s =new Set(数组);
```

###### 23.JavaScript 中的事件代理是什么？

```
答：

事件代理（Event Delegation），又称之为事件委托。
“事件代理”即是把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务。
原理：利用DOM元素的事件冒泡(捕获阶段-事件执行阶段-冒泡阶段)。

优点：
1.可大量节省内存占用，减少事件注册。
2.可实现当新增子对象时无需再次对其绑定（动态绑定事件）

使用：js原生document.addEventListener()
     jqurery $('selector').delegate()

```

###### 24.prototype 和 __proto__ 区别是什么？

###### 25.谈谈你对 JavaScript 中的原型链的理解，原型链的顶端是什么？

```
答：

查找方法的过程，如自身不存在该方法，则会通过原型链向上一直查找，存在则使用，不存在则一直找直到找到null。
```



###### 26.Vue 和 React 的有什么异同？

```
答：

均为js的框架，组件化，vdom。

区别：
1.监听数据变化的实现原理不同
Vue和React设计理念上的区别，Vue使用的是可变数据，而React更强调数据的不可变，两者无好坏之分，Vue更加简单，而React构建大型应用的时候更加鲁棒。
Vue通过 getter/setter以及一些函数的劫持，能精确知道数据变化。
React默认是通过比较引用的方式（diff）进行的，如不优化可能导致大量不必要的VDOM的重新渲染。
2.数据流的不同
Vue数据双向绑定
React单向数据流，称之为onChange/setState()模式。
3.组件通信的区别
https://zhuanlan.zhihu.com/p/100228073
```



###### 27.什么是 JSX？

```

答：

1.react特有的，是一个 JavaScript 的语法扩展。具有 JavaScript 的全部功能。js里面可以写html代码

2.一些语法的改变。基本：{变量}，其次class为关键字 用className代替class  htmlFor 代替for等，内联样式style用法的改变 style={{color："red“}}。双层括号的含义：js代码需要在{}中，style里面本身需要一个对象。

3.与vue一样 遍历对象 数组时 需要唯一的key值。
```



###### 28.AJAX 的工作原理？

```

答：

工作原理相当于在用户和服务器之间加了—个中间层，使用户操作与服务器响应异步化。可将服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理，减轻服务器和带宽的负担。
Ajax的核心是JavaScript对象XmlHttpRequest。该对象在Internet Explorer 5中首次引入，它是一种支持异步请求的技术，XmlHttpRequest使您可使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。
```



###### 29.深拷贝和浅拷贝分别是什么？什么时候需要深拷贝？如何实现深拷贝？



###### 30.层叠上下文、层叠等级、层叠顺序

```
答：

层叠上下文：是一种概念。
当元A与B元素发生堆叠，A被B覆盖。此时A和B就是层叠上下文的关系。

层叠等级 ：是一种概念。
 1.在同一个层叠上下文中，描述定义的是该层叠上下文中的元素在Z轴上的上下顺序。
 2.在其他普通元素中，描述定义的是这些普通元素在Z轴上的上下顺序。

层叠顺序：是一种规则。表示元素发生层叠时按照特定的顺序规则在Z轴上垂直显示。

具体规则：层叠上下文 z-index<0 block块级水平盒子 float浮动盒子 inline/inline-block水平盒子 z-index：auto/0 z-index>0

判断谁在上下时:
1.处于同一个层叠上下文中，层叠等级大的在上面
2.不在统一层叠上下文中，比较所处的层叠上下文的层叠等级
3.当两个元素层叠等级相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上。

```



###### 31.em 和 rem 的区别是什么？

```
答：

Em 和 rem都是灵活、 可扩展的单位，由浏览器转换为像素值。

两者区别：
rem 单位翻译为像素值是由 html 元素的字体大小决定的。 此字体大小会被浏览器中字体大小的设置影响。
em 单位转为像素值，取决于他们使用的字体大小。 此字体大小受从父元素继承过来的字体大小。

```



###### 32.CSS 中 display: none、visibility: hidden、opactiy: 0 的区别。

```
答：

display: "none" ：元素不渲染，不会占据位置，切换“显隐”时会触发渲染，会影响性能。
opacity: 0：只是透明度改变，与visibility: "hidden" ：元素是会渲染，会占据页面中的位置，切换“显隐”时会触发重绘，基本不影响性能。
```



###### 33.GET 和 POST 有哪些区别？

```
答：

主要区别：
① get数据在URL中对所有人都是可见的，因URL的长度是受限制的，故get有长度限制。而POST数据不会显示在 URL中。POST安全性更高
② get能被缓存，可收藏为书签，后退按钮/刷新 数据不会被重新提交，参数保留在浏览器历史中。

```



###### 34.ES6 的新特性有哪些？

```
答：

let与const  模拟出块级作用域，弥补js无块级作用域的缺陷。

解构赋值 扩展运算符的使用

箭头函数
```



###### 35.简单描述在浏览器中输入 url 回车后的过程。

```
答：

第一步：客户机提出域名解析请求,并将该请求发送给本地的域名服务器。
第二步：当本地域名服务器收到请求后,先查询本地的缓存,如有该纪录项,则本地的域名服务器就直接把查询的结果返回。
第三步：如本地的缓存中无该纪录,则本地域名服务器就直接把请求发给根域名服务器,然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址。
第四步：本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址。
第五步：重复第四步,直到找到正确的纪录。
```



###### 36.谈谈你对 SEO 的理解。

```
答：

SEO（Search Engine Optimization）：搜索引擎优化。
是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是让其在行业内占据领先地位，获得品牌收益。很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移。
```



###### 38.js检验数据类型的方法？

```
答：

① typeof  注意 typeof null 输出object typeof undefined 输出undefined   不实用
② instanceof 
③ constructor 通过实列指向原型判断
④ Object.prototype.toString.call(obj) 可以用来检测传入参数的数据类型，最常见的就是用来检测数组。

  原理：所有类在继承Object后，改写了toString()方法。不同的对象类型调用toString方法时，调用的是对应的重        写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符              串.....），而不会去调用Object上原型toString方法
  数组自带方法 isArray() 能单独判断是否为数组
```

###### 39.less、scss、stylus三者区别

```
答：

三者都是css预编译，使得CSS 更见简洁，适应性更强，代码更直观

区别:

1.书写上：scss：花括号和分号可选。stylus：花括号、分号、冒号可选。

2.变量上：less @ 、sass $、stylus对变量是没有任何设定的，可是以除@的任何的字符且与变量之间可用冒号，空格隔开

3.Mixins（混入）：less .style(@变量),调用: .style(参数);
				sass  @style($变量),调用: @style(参数);
				stylus  style(变量),调用: style(参数);
4.继承:      		Stylus,Scss  @extend .style    
				less &:extend(.style);
```



###### 39.$route 和 $router 的区别？

```
答：

1.$route 是“路由信息对象”，包括 path(当前路由的路径)、params、hash、query、fullPath、matched、name(当前路径名字)等路由信息参数。
$route.params一个 key/value 对象，包含了 动态片段 和 全匹配片段， 如果没有路由参数，就是一个空对象。
$route.query一个 key/value 对象，表示 URL 查询参数。 
$route.hash当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。
$route.fullPath完成解析后的 URL，包含查询参数和 hash 的完整路径。
$route.matched数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。

2.$router 是“路由实例”对象，即使用 new VueRouter创建的实例，包括了路由的跳转方法，钩子函数等。

注意：

$router.push和$router.replace的区别：

 ① 使用push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。
 ② 使用replace方法不会向 history 添加新记录，而是替换掉当前的 history 记录，即当replace跳转到的网页    后，‘后退’按钮不能查看之前的页面。
```

###### 40.vue created与mounted区别

```
答：

created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。

mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

其实两者比较好理解，通常created使用的次数多，而mounted通常是在一些插件的使用或者组件的使用中进行操作，比如插件chart.js的使用: var ctx = document.getElementById(ID);通常会有这一步，而如果你写入组件中，你会发现在created中无法对chart进行一些初始化配置，一定要等这个html渲染完后才可以进行，那么mounted就是不二之选。下面看一个例子（用组件）。

```

